<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>trappedbot.chat_functions API documentation</title>
<meta name="description" content="Chat functions …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>trappedbot.chat_functions</code></h1>
</header>
<section id="section-intro">
<p>Chat functions</p>
<p>This file implements utility functions for
- sending text messages
- sending images
- sending of other files like audio, video, text, PDFs, .doc, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

&#34;&#34;&#34;Chat functions

This file implements utility functions for
- sending text messages
- sending images
- sending of other files like audio, video, text, PDFs, .doc, etc.
&#34;&#34;&#34;

import html
import os
import traceback
import typing

import aiofiles.os
import magic
from markdown import markdown
from nio import SendRetryError, UploadResponse
from PIL import Image
from nio.client.async_client import AsyncClient
from nio.events.room_events import RoomMessageText
from nio.rooms import MatrixRoom

from trappedbot.applogger import LOGGER
from trappedbot.mxutil import MessageFormat


def reply_fallback_html_from_message(
    room_id: str, event_id: str, sender_mxid: str, sender_displayname: str, content: str
) -&gt; str:
    &#34;&#34;&#34;Generate reply fallback from a message&#34;&#34;&#34;
    fallback = (
        f&#34;&lt;mx-reply&gt;&lt;blockquote&gt;&#34;
        f&#34;&lt;a href=&#39;https://matrix.to/#/{room_id}/{event_id}&#39;&gt;In reply to&lt;/a&gt; &#34;
        f&#34;&lt;a href=&#39;https://matrix.to/#/{sender_mxid}&#39;&gt;{sender_displayname}&lt;/a&gt;&lt;br/&gt;&#34;
        f&#34;{content}&#34;
        f&#34;&lt;/blockquote&gt;&lt;/mx-reply&gt;&#34;
    )
    return fallback


def reply_fallback_text_from_message(
    sender_displayname: str,
    content: str,
) -&gt; str:
    &#34;&#34;&#34;Generate a reply fallback from a text message&#34;&#34;&#34;
    fallback = &#34;&#34;
    for idx, line in enumerate(content):
        if idx == 0:
            fallback += f&#34;&gt; &lt;{sender_displayname}&gt; {line}&#34;
        else:
            fallback += f&#34;&gt; {line}&#34;
    return fallback


async def send_text_to_room(
    client: AsyncClient,
    room_id: str,
    message: str,
    notice: bool = True,
    format: typing.Optional[MessageFormat] = MessageFormat.NATURAL,
    split: typing.Optional[str] = None,
    replyto: typing.Optional[RoomMessageText] = None,
    replyto_room: typing.Optional[MatrixRoom] = None,
):
    &#34;&#34;&#34;Send text to a matrix room.

    Arguments:
    ---------
    client: The client to communicate with Matrix
    room_id: The ID of the room to send the message to
    message: The message content
    notice: Whether the message should be sent with an
        &#34;m.notice&#34; message type (will not ping users)
    format: The format for the message
    split: if set, split the message into multiple messages wherever
        the string specified in split occurs
        Defaults to None
    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_text_to_room {room_id} {message}&#34;)
    messages = []
    if split:
        for paragraph in message.split(split):
            # strip again to get get rid of leading/trailing newlines and
            # whitespaces left over from previous split
            if paragraph.strip() != &#34;&#34;:
                messages.append(paragraph)
    else:
        messages.append(message)

    for message in messages:
        # Determine whether to ping room members or not
        msgtype = &#34;m.notice&#34; if notice else &#34;m.text&#34;

        content: typing.Dict[str, typing.Any] = {
            &#34;msgtype&#34;: msgtype,
            &#34;body&#34;: message,
        }
        if format == MessageFormat.FORMATTED:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = message
        elif format == MessageFormat.MARKDOWN:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = markdown(message)
        elif format == MessageFormat.CODE:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = &#34;&lt;pre&gt;&lt;code&gt;&#34; + message + &#34;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;
            # next line: work-around for Element on Android
            content[&#34;body&#34;] = &#34;```\n&#34; + message + &#34;\n```&#34;  # to format it as code
        else:
            pass

        if (replyto and not replyto_room) or (not replyto and replyto_room):
            LOGGER.error(
                f&#34;send_text_to_room was passed only one of replyto and replyto_room, NOT sending message as reply&#34;
            )
        elif replyto and replyto_room:
            LOGGER.debug(f&#34;send_text_to_room replying to message {replyto.event_id}&#34;)

            # If there was no HTML-formatted body in the original message,
            # build one from the unformatted body.
            if (
                not content.get(&#34;formatted_body&#34;)
                or content.get(&#34;format&#34;) != &#34;org.matrix.custom.html&#34;
            ):
                content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
                content[&#34;formatted_body&#34;] = html.escape(content[&#34;body&#34;])

            content[&#34;body&#34;] = (
                reply_fallback_text_from_message(replyto.sender, replyto.body)
                + content[&#34;body&#34;]
            )
            content[&#34;formatted_body&#34;] = (
                reply_fallback_html_from_message(
                    replyto_room.canonical_alias or replyto_room.room_id,
                    replyto.event_id,
                    replyto.sender,
                    replyto_room.user_name(replyto.sender) or replyto.sender,
                    replyto.body,
                )
                + content[&#34;formatted_body&#34;]
            )
            content[&#34;m.relates_to&#34;] = {
                &#34;m.in_reply_to&#34;: {
                    &#34;event_id&#34;: replyto.event_id,
                }
            }

        try:
            await client.room_send(
                room_id,
                &#34;m.room.message&#34;,
                content,
                ignore_unverified_devices=True,
            )
        except SendRetryError:
            LOGGER.exception(f&#34;Unable to send message response to {room_id}&#34;)


async def send_image_to_room(client, room_id, image):
    &#34;&#34;&#34;Send image to single room.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the message to
    image (str): file name/path of image

    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_image_to_room {room_id} {image}&#34;)
    await send_image_to_rooms(client, [room_id], image)


async def send_image_to_rooms(client, rooms, image):
    &#34;&#34;&#34;Send image to multiple rooms.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    rooms (list): list of room_id-s
    image (str): file name/path of image

    This is a working example for a JPG image.
        &#34;content&#34;: {
            &#34;body&#34;: &#34;someimage.jpg&#34;,
            &#34;info&#34;: {
                &#34;size&#34;: 5420,
                &#34;mimetype&#34;: &#34;image/jpeg&#34;,
                &#34;thumbnail_info&#34;: {
                    &#34;w&#34;: 100,
                    &#34;h&#34;: 100,
                    &#34;mimetype&#34;: &#34;image/jpeg&#34;,
                    &#34;size&#34;: 2106
                },
                &#34;w&#34;: 100,
                &#34;h&#34;: 100,
                &#34;thumbnail_url&#34;: &#34;mxc://example.com/SomeStrangeThumbnailUriKey&#34;
            },
            &#34;msgtype&#34;: &#34;m.image&#34;,
            &#34;url&#34;: &#34;mxc://example.com/SomeStrangeUriKey&#34;
        }

    &#34;&#34;&#34;
    if not rooms:
        LOGGER.info(
            &#34;No rooms are given. This should not happen. &#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return
    if not os.path.isfile(image):
        LOGGER.debug(
            f&#34;File {image} is not a file. Doesn&#39;t exist or &#34;
            &#34;is a directory.&#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return

    mime_type = magic.from_file(image, mime=True)  # e.g. &#34;image/jpeg&#34;
    if not mime_type.startswith(&#34;image/&#34;):
        LOGGER.debug(&#34;Drop message because file does not have an image mime type.&#34;)
        return

    im = Image.open(image)
    (width, height) = im.size  # im.size returns (width,height) tuple

    # first do an upload of image, then send URI of upload to room
    file_stat = await aiofiles.os.stat(image)
    async with aiofiles.open(image, &#34;r+b&#34;) as f:
        resp, maybe_keys = await client.upload(
            f,
            content_type=mime_type,  # image/jpeg
            filename=os.path.basename(image),
            filesize=file_stat.st_size,
        )
    if isinstance(resp, UploadResponse):
        LOGGER.debug(&#34;Image was uploaded successfully to server. &#34;)
    else:
        LOGGER.debug(f&#34;Failed to upload image. Failure response: {resp}&#34;)

    content = {
        &#34;body&#34;: os.path.basename(image),  # descriptive title
        &#34;info&#34;: {
            &#34;size&#34;: file_stat.st_size,
            &#34;mimetype&#34;: mime_type,
            &#34;thumbnail_info&#34;: None,  # TODO
            &#34;w&#34;: width,  # width in pixel
            &#34;h&#34;: height,  # height in pixel
            &#34;thumbnail_url&#34;: None,  # TODO
        },
        &#34;msgtype&#34;: &#34;m.image&#34;,
        &#34;url&#34;: resp.content_uri,
    }

    try:
        for room_id in rooms:
            await client.room_send(
                room_id, message_type=&#34;m.room.message&#34;, content=content
            )
            LOGGER.debug(f&#39;This image was sent: &#34;{image}&#34; to room &#34;{room_id}&#34;.&#39;)
    except Exception:
        LOGGER.debug(
            f&#34;Image send of file {image} failed. &#34; &#34;Sorry. Here is the traceback.&#34;
        )
        LOGGER.debug(traceback.format_exc())


async def send_file_to_room(client, room_id, file):
    &#34;&#34;&#34;Send file to single room.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the file to
    file (str): file name/path of file

    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_file_to_room {room_id} {file}&#34;)
    await send_file_to_rooms(client, [room_id], file)


async def send_file_to_rooms(client, rooms, file):
    &#34;&#34;&#34;Send file to multiple rooms.

    Upload file to server and then send link to rooms.
    Works and tested for .pdf, .txt, .ogg, .wav.
    All these file types are treated the same.

    Do not use this function for images.
    Use the send_image_to_room() function for images.

    Matrix has types for audio and video (and image and file).
    See: &#34;msgtype&#34; == &#34;m.image&#34;, m.audio, m.video, m.file

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the file to
    rooms (list): list of room_id-s
    file (str): file name/path of file

    This is a working example for a PDF file.
    It can be viewed or downloaded from:
    https://matrix.example.com/_matrix/media/r0/download/
        example.com/SomeStrangeUriKey # noqa
    {
        &#34;type&#34;: &#34;m.room.message&#34;,
        &#34;sender&#34;: &#34;@someuser:example.com&#34;,
        &#34;content&#34;: {
            &#34;body&#34;: &#34;example.pdf&#34;,
            &#34;info&#34;: {
                &#34;size&#34;: 6301234,
                &#34;mimetype&#34;: &#34;application/pdf&#34;
                },
            &#34;msgtype&#34;: &#34;m.file&#34;,
            &#34;url&#34;: &#34;mxc://example.com/SomeStrangeUriKey&#34;
        },
        &#34;origin_server_ts&#34;: 1595100000000,
        &#34;unsigned&#34;: {
            &#34;age&#34;: 1000,
            &#34;transaction_id&#34;: &#34;SomeTxId01234567&#34;
        },
        &#34;event_id&#34;: &#34;$SomeEventId01234567789Abcdef012345678&#34;,
        &#34;room_id&#34;: &#34;!SomeRoomId:example.com&#34;
    }

    &#34;&#34;&#34;
    if not rooms:
        LOGGER.info(
            &#34;No rooms are given. This should not happen. &#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return
    if not os.path.isfile(file):
        LOGGER.debug(
            f&#34;File {file} is not a file. Doesn&#39;t exist or &#34;
            &#34;is a directory.&#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return

    # # restrict to &#34;txt&#34;, &#34;pdf&#34;, &#34;mp3&#34;, &#34;ogg&#34;, &#34;wav&#34;, ...
    # if not re.match(&#34;^.pdf$|^.txt$|^.doc$|^.xls$|^.mobi$|^.mp3$&#34;,
    #                os.path.splitext(file)[1].lower()):
    #    LOGGER.debug(f&#34;File {file} is not a permitted file type. Should be &#34;
    #                 &#34;.pdf, .txt, .doc, .xls, .mobi or .mp3 ... &#34;
    #                 f&#34;[{os.path.splitext(file)[1].lower()}]&#34;
    #                 &#34;This file is being droppend and NOT sent.&#34;)
    #    return

    # &#39;application/pdf&#39; &#34;plain/text&#34; &#34;audio/ogg&#34;
    mime_type = magic.from_file(file, mime=True)
    # if ((not mime_type.startswith(&#34;application/&#34;)) and
    #        (not mime_type.startswith(&#34;plain/&#34;)) and
    #        (not mime_type.startswith(&#34;audio/&#34;))):
    #    LOGGER.debug(f&#34;File {file} does not have an accepted mime type. &#34;
    #                 &#34;Should be something like application/pdf. &#34;
    #                 f&#34;Found mime type {mime_type}. &#34;
    #                 &#34;This file is being droppend and NOT sent.&#34;)
    #    return

    # first do an upload of file, see upload() in documentation
    # http://matrix-nio.readthedocs.io/en/latest/nio.html#nio.AsyncClient.upload
    # then send URI of upload to room

    file_stat = await aiofiles.os.stat(file)
    async with aiofiles.open(file, &#34;r+b&#34;) as f:
        resp, maybe_keys = await client.upload(
            f,
            content_type=mime_type,  # application/pdf
            filename=os.path.basename(file),
            filesize=file_stat.st_size,
        )
    if isinstance(resp, UploadResponse):
        LOGGER.debug(f&#34;File was uploaded successfully to server. Response is: {resp}&#34;)
    else:
        LOGGER.info(
            &#34;Bot failed to upload. &#34;
            &#34;Please retry. This could be temporary issue on your server. &#34;
            &#34;Sorry.&#34;
        )
        LOGGER.info(
            f&#39;file=&#34;{file}&#34;; mime_type=&#34;{mime_type}&#34;; &#39;
            f&#39;filessize=&#34;{file_stat.st_size}&#34;&#39;
            f&#34;Failed to upload: {resp}&#34;
        )

    # determine msg_type:
    if mime_type.startswith(&#34;audio/&#34;):
        msg_type = &#34;m.audio&#34;
    elif mime_type.startswith(&#34;video/&#34;):
        msg_type = &#34;m.video&#34;
    else:
        msg_type = &#34;m.file&#34;

    content = {
        &#34;body&#34;: os.path.basename(file),  # descriptive title
        &#34;info&#34;: {
            &#34;size&#34;: file_stat.st_size,
            &#34;mimetype&#34;: mime_type,
        },  # noqa
        &#34;msgtype&#34;: msg_type,
        &#34;url&#34;: resp.content_uri,
    }

    try:
        for room_id in rooms:
            await client.room_send(
                room_id, message_type=&#34;m.room.message&#34;, content=content
            )
            LOGGER.debug(f&#39;This file was sent: &#34;{file}&#34; to room &#34;{room_id}&#34;.&#39;)
    except Exception:
        LOGGER.debug(f&#34;File send of file {file} failed. Sorry. Here is the traceback.&#34;)
        LOGGER.debug(traceback.format_exc())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="trappedbot.chat_functions.reply_fallback_html_from_message"><code class="name flex">
<span>def <span class="ident">reply_fallback_html_from_message</span></span>(<span>room_id: str, event_id: str, sender_mxid: str, sender_displayname: str, content: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate reply fallback from a message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_fallback_html_from_message(
    room_id: str, event_id: str, sender_mxid: str, sender_displayname: str, content: str
) -&gt; str:
    &#34;&#34;&#34;Generate reply fallback from a message&#34;&#34;&#34;
    fallback = (
        f&#34;&lt;mx-reply&gt;&lt;blockquote&gt;&#34;
        f&#34;&lt;a href=&#39;https://matrix.to/#/{room_id}/{event_id}&#39;&gt;In reply to&lt;/a&gt; &#34;
        f&#34;&lt;a href=&#39;https://matrix.to/#/{sender_mxid}&#39;&gt;{sender_displayname}&lt;/a&gt;&lt;br/&gt;&#34;
        f&#34;{content}&#34;
        f&#34;&lt;/blockquote&gt;&lt;/mx-reply&gt;&#34;
    )
    return fallback</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.reply_fallback_text_from_message"><code class="name flex">
<span>def <span class="ident">reply_fallback_text_from_message</span></span>(<span>sender_displayname: str, content: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a reply fallback from a text message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_fallback_text_from_message(
    sender_displayname: str,
    content: str,
) -&gt; str:
    &#34;&#34;&#34;Generate a reply fallback from a text message&#34;&#34;&#34;
    fallback = &#34;&#34;
    for idx, line in enumerate(content):
        if idx == 0:
            fallback += f&#34;&gt; &lt;{sender_displayname}&gt; {line}&#34;
        else:
            fallback += f&#34;&gt; {line}&#34;
    return fallback</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.send_file_to_room"><code class="name flex">
<span>async def <span class="ident">send_file_to_room</span></span>(<span>client, room_id, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Send file to single room.</p>
<h2 id="arguments">Arguments:</h2>
<p>client (nio.AsyncClient): The client to communicate with Matrix
room_id (str): The ID of the room to send the file to
file (str): file name/path of file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_file_to_room(client, room_id, file):
    &#34;&#34;&#34;Send file to single room.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the file to
    file (str): file name/path of file

    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_file_to_room {room_id} {file}&#34;)
    await send_file_to_rooms(client, [room_id], file)</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.send_file_to_rooms"><code class="name flex">
<span>async def <span class="ident">send_file_to_rooms</span></span>(<span>client, rooms, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Send file to multiple rooms.</p>
<p>Upload file to server and then send link to rooms.
Works and tested for .pdf, .txt, .ogg, .wav.
All these file types are treated the same.</p>
<p>Do not use this function for images.
Use the send_image_to_room() function for images.</p>
<p>Matrix has types for audio and video (and image and file).
See: "msgtype" == "m.image", m.audio, m.video, m.file</p>
<h2 id="arguments">Arguments:</h2>
<p>client (nio.AsyncClient): The client to communicate with Matrix
room_id (str): The ID of the room to send the file to
rooms (list): list of room_id-s
file (str): file name/path of file</p>
<p>This is a working example for a PDF file.
It can be viewed or downloaded from:
<a href="https://matrix.example.com/_matrix/media/r0/download/">https://matrix.example.com/_matrix/media/r0/download/</a>
example.com/SomeStrangeUriKey # noqa
{
"type": "m.room.message",
"sender": "@someuser:example.com",
"content": {
"body": "example.pdf",
"info": {
"size": 6301234,
"mimetype": "application/pdf"
},
"msgtype": "m.file",
"url": "mxc://example.com/SomeStrangeUriKey"
},
"origin_server_ts": 1595100000000,
"unsigned": {
"age": 1000,
"transaction_id": "SomeTxId01234567"
},
"event_id": "$SomeEventId01234567789Abcdef012345678",
"room_id": "!SomeRoomId:example.com"
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_file_to_rooms(client, rooms, file):
    &#34;&#34;&#34;Send file to multiple rooms.

    Upload file to server and then send link to rooms.
    Works and tested for .pdf, .txt, .ogg, .wav.
    All these file types are treated the same.

    Do not use this function for images.
    Use the send_image_to_room() function for images.

    Matrix has types for audio and video (and image and file).
    See: &#34;msgtype&#34; == &#34;m.image&#34;, m.audio, m.video, m.file

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the file to
    rooms (list): list of room_id-s
    file (str): file name/path of file

    This is a working example for a PDF file.
    It can be viewed or downloaded from:
    https://matrix.example.com/_matrix/media/r0/download/
        example.com/SomeStrangeUriKey # noqa
    {
        &#34;type&#34;: &#34;m.room.message&#34;,
        &#34;sender&#34;: &#34;@someuser:example.com&#34;,
        &#34;content&#34;: {
            &#34;body&#34;: &#34;example.pdf&#34;,
            &#34;info&#34;: {
                &#34;size&#34;: 6301234,
                &#34;mimetype&#34;: &#34;application/pdf&#34;
                },
            &#34;msgtype&#34;: &#34;m.file&#34;,
            &#34;url&#34;: &#34;mxc://example.com/SomeStrangeUriKey&#34;
        },
        &#34;origin_server_ts&#34;: 1595100000000,
        &#34;unsigned&#34;: {
            &#34;age&#34;: 1000,
            &#34;transaction_id&#34;: &#34;SomeTxId01234567&#34;
        },
        &#34;event_id&#34;: &#34;$SomeEventId01234567789Abcdef012345678&#34;,
        &#34;room_id&#34;: &#34;!SomeRoomId:example.com&#34;
    }

    &#34;&#34;&#34;
    if not rooms:
        LOGGER.info(
            &#34;No rooms are given. This should not happen. &#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return
    if not os.path.isfile(file):
        LOGGER.debug(
            f&#34;File {file} is not a file. Doesn&#39;t exist or &#34;
            &#34;is a directory.&#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return

    # # restrict to &#34;txt&#34;, &#34;pdf&#34;, &#34;mp3&#34;, &#34;ogg&#34;, &#34;wav&#34;, ...
    # if not re.match(&#34;^.pdf$|^.txt$|^.doc$|^.xls$|^.mobi$|^.mp3$&#34;,
    #                os.path.splitext(file)[1].lower()):
    #    LOGGER.debug(f&#34;File {file} is not a permitted file type. Should be &#34;
    #                 &#34;.pdf, .txt, .doc, .xls, .mobi or .mp3 ... &#34;
    #                 f&#34;[{os.path.splitext(file)[1].lower()}]&#34;
    #                 &#34;This file is being droppend and NOT sent.&#34;)
    #    return

    # &#39;application/pdf&#39; &#34;plain/text&#34; &#34;audio/ogg&#34;
    mime_type = magic.from_file(file, mime=True)
    # if ((not mime_type.startswith(&#34;application/&#34;)) and
    #        (not mime_type.startswith(&#34;plain/&#34;)) and
    #        (not mime_type.startswith(&#34;audio/&#34;))):
    #    LOGGER.debug(f&#34;File {file} does not have an accepted mime type. &#34;
    #                 &#34;Should be something like application/pdf. &#34;
    #                 f&#34;Found mime type {mime_type}. &#34;
    #                 &#34;This file is being droppend and NOT sent.&#34;)
    #    return

    # first do an upload of file, see upload() in documentation
    # http://matrix-nio.readthedocs.io/en/latest/nio.html#nio.AsyncClient.upload
    # then send URI of upload to room

    file_stat = await aiofiles.os.stat(file)
    async with aiofiles.open(file, &#34;r+b&#34;) as f:
        resp, maybe_keys = await client.upload(
            f,
            content_type=mime_type,  # application/pdf
            filename=os.path.basename(file),
            filesize=file_stat.st_size,
        )
    if isinstance(resp, UploadResponse):
        LOGGER.debug(f&#34;File was uploaded successfully to server. Response is: {resp}&#34;)
    else:
        LOGGER.info(
            &#34;Bot failed to upload. &#34;
            &#34;Please retry. This could be temporary issue on your server. &#34;
            &#34;Sorry.&#34;
        )
        LOGGER.info(
            f&#39;file=&#34;{file}&#34;; mime_type=&#34;{mime_type}&#34;; &#39;
            f&#39;filessize=&#34;{file_stat.st_size}&#34;&#39;
            f&#34;Failed to upload: {resp}&#34;
        )

    # determine msg_type:
    if mime_type.startswith(&#34;audio/&#34;):
        msg_type = &#34;m.audio&#34;
    elif mime_type.startswith(&#34;video/&#34;):
        msg_type = &#34;m.video&#34;
    else:
        msg_type = &#34;m.file&#34;

    content = {
        &#34;body&#34;: os.path.basename(file),  # descriptive title
        &#34;info&#34;: {
            &#34;size&#34;: file_stat.st_size,
            &#34;mimetype&#34;: mime_type,
        },  # noqa
        &#34;msgtype&#34;: msg_type,
        &#34;url&#34;: resp.content_uri,
    }

    try:
        for room_id in rooms:
            await client.room_send(
                room_id, message_type=&#34;m.room.message&#34;, content=content
            )
            LOGGER.debug(f&#39;This file was sent: &#34;{file}&#34; to room &#34;{room_id}&#34;.&#39;)
    except Exception:
        LOGGER.debug(f&#34;File send of file {file} failed. Sorry. Here is the traceback.&#34;)
        LOGGER.debug(traceback.format_exc())</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.send_image_to_room"><code class="name flex">
<span>async def <span class="ident">send_image_to_room</span></span>(<span>client, room_id, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Send image to single room.</p>
<h2 id="arguments">Arguments:</h2>
<p>client (nio.AsyncClient): The client to communicate with Matrix
room_id (str): The ID of the room to send the message to
image (str): file name/path of image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_image_to_room(client, room_id, image):
    &#34;&#34;&#34;Send image to single room.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    room_id (str): The ID of the room to send the message to
    image (str): file name/path of image

    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_image_to_room {room_id} {image}&#34;)
    await send_image_to_rooms(client, [room_id], image)</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.send_image_to_rooms"><code class="name flex">
<span>async def <span class="ident">send_image_to_rooms</span></span>(<span>client, rooms, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Send image to multiple rooms.</p>
<h2 id="arguments">Arguments:</h2>
<p>client (nio.AsyncClient): The client to communicate with Matrix
rooms (list): list of room_id-s
image (str): file name/path of image</p>
<p>This is a working example for a JPG image.
"content": {
"body": "someimage.jpg",
"info": {
"size": 5420,
"mimetype": "image/jpeg",
"thumbnail_info": {
"w": 100,
"h": 100,
"mimetype": "image/jpeg",
"size": 2106
},
"w": 100,
"h": 100,
"thumbnail_url": "mxc://example.com/SomeStrangeThumbnailUriKey"
},
"msgtype": "m.image",
"url": "mxc://example.com/SomeStrangeUriKey"
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_image_to_rooms(client, rooms, image):
    &#34;&#34;&#34;Send image to multiple rooms.

    Arguments:
    ---------
    client (nio.AsyncClient): The client to communicate with Matrix
    rooms (list): list of room_id-s
    image (str): file name/path of image

    This is a working example for a JPG image.
        &#34;content&#34;: {
            &#34;body&#34;: &#34;someimage.jpg&#34;,
            &#34;info&#34;: {
                &#34;size&#34;: 5420,
                &#34;mimetype&#34;: &#34;image/jpeg&#34;,
                &#34;thumbnail_info&#34;: {
                    &#34;w&#34;: 100,
                    &#34;h&#34;: 100,
                    &#34;mimetype&#34;: &#34;image/jpeg&#34;,
                    &#34;size&#34;: 2106
                },
                &#34;w&#34;: 100,
                &#34;h&#34;: 100,
                &#34;thumbnail_url&#34;: &#34;mxc://example.com/SomeStrangeThumbnailUriKey&#34;
            },
            &#34;msgtype&#34;: &#34;m.image&#34;,
            &#34;url&#34;: &#34;mxc://example.com/SomeStrangeUriKey&#34;
        }

    &#34;&#34;&#34;
    if not rooms:
        LOGGER.info(
            &#34;No rooms are given. This should not happen. &#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return
    if not os.path.isfile(image):
        LOGGER.debug(
            f&#34;File {image} is not a file. Doesn&#39;t exist or &#34;
            &#34;is a directory.&#34;
            &#34;This file is being droppend and NOT sent.&#34;
        )
        return

    mime_type = magic.from_file(image, mime=True)  # e.g. &#34;image/jpeg&#34;
    if not mime_type.startswith(&#34;image/&#34;):
        LOGGER.debug(&#34;Drop message because file does not have an image mime type.&#34;)
        return

    im = Image.open(image)
    (width, height) = im.size  # im.size returns (width,height) tuple

    # first do an upload of image, then send URI of upload to room
    file_stat = await aiofiles.os.stat(image)
    async with aiofiles.open(image, &#34;r+b&#34;) as f:
        resp, maybe_keys = await client.upload(
            f,
            content_type=mime_type,  # image/jpeg
            filename=os.path.basename(image),
            filesize=file_stat.st_size,
        )
    if isinstance(resp, UploadResponse):
        LOGGER.debug(&#34;Image was uploaded successfully to server. &#34;)
    else:
        LOGGER.debug(f&#34;Failed to upload image. Failure response: {resp}&#34;)

    content = {
        &#34;body&#34;: os.path.basename(image),  # descriptive title
        &#34;info&#34;: {
            &#34;size&#34;: file_stat.st_size,
            &#34;mimetype&#34;: mime_type,
            &#34;thumbnail_info&#34;: None,  # TODO
            &#34;w&#34;: width,  # width in pixel
            &#34;h&#34;: height,  # height in pixel
            &#34;thumbnail_url&#34;: None,  # TODO
        },
        &#34;msgtype&#34;: &#34;m.image&#34;,
        &#34;url&#34;: resp.content_uri,
    }

    try:
        for room_id in rooms:
            await client.room_send(
                room_id, message_type=&#34;m.room.message&#34;, content=content
            )
            LOGGER.debug(f&#39;This image was sent: &#34;{image}&#34; to room &#34;{room_id}&#34;.&#39;)
    except Exception:
        LOGGER.debug(
            f&#34;Image send of file {image} failed. &#34; &#34;Sorry. Here is the traceback.&#34;
        )
        LOGGER.debug(traceback.format_exc())</code></pre>
</details>
</dd>
<dt id="trappedbot.chat_functions.send_text_to_room"><code class="name flex">
<span>async def <span class="ident">send_text_to_room</span></span>(<span>client: nio.client.async_client.AsyncClient, room_id: str, message: str, notice: bool = True, format: Union[<a title="trappedbot.mxutil.MessageFormat" href="mxutil.html#trappedbot.mxutil.MessageFormat">MessageFormat</a>, NoneType] = MessageFormat.NATURAL, split: Union[str, NoneType] = None, replyto: Union[nio.events.room_events.RoomMessageText, NoneType] = None, replyto_room: Union[nio.rooms.MatrixRoom, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send text to a matrix room.</p>
<h2 id="arguments">Arguments:</h2>
<p>client: The client to communicate with Matrix
room_id: The ID of the room to send the message to
message: The message content
notice: Whether the message should be sent with an
"m.notice" message type (will not ping users)
format: The format for the message
split: if set, split the message into multiple messages wherever
the string specified in split occurs
Defaults to None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_text_to_room(
    client: AsyncClient,
    room_id: str,
    message: str,
    notice: bool = True,
    format: typing.Optional[MessageFormat] = MessageFormat.NATURAL,
    split: typing.Optional[str] = None,
    replyto: typing.Optional[RoomMessageText] = None,
    replyto_room: typing.Optional[MatrixRoom] = None,
):
    &#34;&#34;&#34;Send text to a matrix room.

    Arguments:
    ---------
    client: The client to communicate with Matrix
    room_id: The ID of the room to send the message to
    message: The message content
    notice: Whether the message should be sent with an
        &#34;m.notice&#34; message type (will not ping users)
    format: The format for the message
    split: if set, split the message into multiple messages wherever
        the string specified in split occurs
        Defaults to None
    &#34;&#34;&#34;
    LOGGER.debug(f&#34;send_text_to_room {room_id} {message}&#34;)
    messages = []
    if split:
        for paragraph in message.split(split):
            # strip again to get get rid of leading/trailing newlines and
            # whitespaces left over from previous split
            if paragraph.strip() != &#34;&#34;:
                messages.append(paragraph)
    else:
        messages.append(message)

    for message in messages:
        # Determine whether to ping room members or not
        msgtype = &#34;m.notice&#34; if notice else &#34;m.text&#34;

        content: typing.Dict[str, typing.Any] = {
            &#34;msgtype&#34;: msgtype,
            &#34;body&#34;: message,
        }
        if format == MessageFormat.FORMATTED:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = message
        elif format == MessageFormat.MARKDOWN:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = markdown(message)
        elif format == MessageFormat.CODE:
            content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
            content[&#34;formatted_body&#34;] = &#34;&lt;pre&gt;&lt;code&gt;&#34; + message + &#34;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;
            # next line: work-around for Element on Android
            content[&#34;body&#34;] = &#34;```\n&#34; + message + &#34;\n```&#34;  # to format it as code
        else:
            pass

        if (replyto and not replyto_room) or (not replyto and replyto_room):
            LOGGER.error(
                f&#34;send_text_to_room was passed only one of replyto and replyto_room, NOT sending message as reply&#34;
            )
        elif replyto and replyto_room:
            LOGGER.debug(f&#34;send_text_to_room replying to message {replyto.event_id}&#34;)

            # If there was no HTML-formatted body in the original message,
            # build one from the unformatted body.
            if (
                not content.get(&#34;formatted_body&#34;)
                or content.get(&#34;format&#34;) != &#34;org.matrix.custom.html&#34;
            ):
                content[&#34;format&#34;] = &#34;org.matrix.custom.html&#34;
                content[&#34;formatted_body&#34;] = html.escape(content[&#34;body&#34;])

            content[&#34;body&#34;] = (
                reply_fallback_text_from_message(replyto.sender, replyto.body)
                + content[&#34;body&#34;]
            )
            content[&#34;formatted_body&#34;] = (
                reply_fallback_html_from_message(
                    replyto_room.canonical_alias or replyto_room.room_id,
                    replyto.event_id,
                    replyto.sender,
                    replyto_room.user_name(replyto.sender) or replyto.sender,
                    replyto.body,
                )
                + content[&#34;formatted_body&#34;]
            )
            content[&#34;m.relates_to&#34;] = {
                &#34;m.in_reply_to&#34;: {
                    &#34;event_id&#34;: replyto.event_id,
                }
            }

        try:
            await client.room_send(
                room_id,
                &#34;m.room.message&#34;,
                content,
                ignore_unverified_devices=True,
            )
        except SendRetryError:
            LOGGER.exception(f&#34;Unable to send message response to {room_id}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="trappedbot" href="index.html">trappedbot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="trappedbot.chat_functions.reply_fallback_html_from_message" href="#trappedbot.chat_functions.reply_fallback_html_from_message">reply_fallback_html_from_message</a></code></li>
<li><code><a title="trappedbot.chat_functions.reply_fallback_text_from_message" href="#trappedbot.chat_functions.reply_fallback_text_from_message">reply_fallback_text_from_message</a></code></li>
<li><code><a title="trappedbot.chat_functions.send_file_to_room" href="#trappedbot.chat_functions.send_file_to_room">send_file_to_room</a></code></li>
<li><code><a title="trappedbot.chat_functions.send_file_to_rooms" href="#trappedbot.chat_functions.send_file_to_rooms">send_file_to_rooms</a></code></li>
<li><code><a title="trappedbot.chat_functions.send_image_to_room" href="#trappedbot.chat_functions.send_image_to_room">send_image_to_room</a></code></li>
<li><code><a title="trappedbot.chat_functions.send_image_to_rooms" href="#trappedbot.chat_functions.send_image_to_rooms">send_image_to_rooms</a></code></li>
<li><code><a title="trappedbot.chat_functions.send_text_to_room" href="#trappedbot.chat_functions.send_text_to_room">send_text_to_room</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>